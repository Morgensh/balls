<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Planet Conquest</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
    <script src="https://unpkg.com/feather-icons"></script>
    <style>
        .pixel {
            /* Removed transition for performance */
        }
     
        .pixel.conquered {
            /* Removed animation for performance */
        }
     
        @keyframes pixel-flash {
            /* Kept but not used */
        }
     
        .country {
            stroke: #2c3e50;
            stroke-width: 0.5;
            cursor: pointer;
        }
     
        .country.neutral {
            fill: #1a2535;
        }
     
        .country.player {
            fill: #ff6b6b;
        }
     
        .country.warring {
            fill: none;
        }
     
        .country:hover {
            stroke: #fff;
            stroke-width: 2;
        }
     
        .country.target {
            stroke: #ff0000;
            stroke-width: 3;
            filter: drop-shadow(0 0 10px #ff0000);
        }
     
        .ocean {
            fill: #0a0d15;
        }
     
        .glow-text {
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.8);
        }
     
        .pulse {
            animation: pulse 2s infinite;
        }
     
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(255, 107, 107, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 107, 107, 0);
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-900 to-gray-800 min-h-screen text-white">
    <div id="start-menu" class="fixed inset-0 bg-gradient-to-br from-gray-900 to-gray-800 flex flex-col items-center justify-center z-50">
        <h1 class="text-4xl md:text-5xl font-bold mb-6 glow-text">üåç Pixel Planet Conquest</h1>
        <p class="text-gray-300 mb-4 text-center max-w-md">–ó–∞–≤–æ—é–π—Ç–µ –º–∏—Ä –ø–æ –æ–¥–Ω–æ–º—É –ø–∏–∫—Å–µ–ª—é –∑–∞ —Ä–∞–∑! –í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∞—Ä—Ç–æ–≤—É—é —Å—Ç—Ä–∞–Ω—É –∏ –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–≤–æ–µ–≤–∞–Ω–∏–µ.</p>
        <select id="start-country" class="bg-gray-700 border-2 border-gray-500 text-white px-4 py-2 rounded-lg mb-4 w-64">
            <!-- Options will be populated dynamically -->
        </select>
        <button id="start-btn" class="bg-green-600 hover:bg-green-500 border-2 border-green-400 text-white px-6 py-3 rounded-lg font-bold transition-all">
            <i data-feather="play" class="inline mr-2"></i> –ù–ê–ß–ê–¢–¨ –ò–ì–†–£
        </button>
    </div>
    <div id="world-map" class="hidden"></div>
    <div id="modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 rounded-xl border-2 border-gray-700 p-6 max-w-sm w-full mx-4">
            <h2 id="modal-title" class="text-2xl font-bold mb-4 glow-text"></h2>
            <p id="modal-text" class="text-gray-300 mb-6"></p>
            <div class="flex justify-end gap-3">
                <button id="modal-reset" class="bg-purple-600 hover:bg-purple-500 border-2 border-purple-400 text-white px-4 py-2 rounded-lg font-bold transition-all" style="display: none;">
                    <i data-feather="refresh-cw" class="inline mr-2"></i> –ù–û–í–ê–Ø –ò–ì–†–ê
                </button>
                <button id="modal-attack" class="bg-red-600 hover:bg-red-500 border-2 border-red-400 text-white px-4 py-2 rounded-lg font-bold transition-all" style="display: none;">
                    <i data-feather="zap" class="inline mr-2"></i> –ê–¢–ê–ö–û–í–ê–¢–¨
                </button>
                <button id="modal-close" class="bg-gray-600 hover:bg-gray-500 border-2 border-gray-400 text-white px-4 py-2 rounded-lg font-bold transition-all">
                    <i data-feather="x" class="inline mr-2"></i> –ó–ê–ö–†–´–¢–¨
                </button>
            </div>
        </div>
    </div>
    <script>
        const width = 1360;
        const height = 600;
        const pixelSize = 8; // Increased for better performance on mobile
     
        let countriesData = [];
        let hoveredCountry = null;
        let targetCountry = null;
        let countryOwners = {};
        let countryPixels = {};
        let svg, g, pixelLayer, countryLayer;
        let warInProgress = false;
        let gameSpeed = 80; // Set to slower speed
        const speeds = {slow: 80, medium: 40, fast: 15};
        let currentSpeed = 'slow';
        let idToGeoIndex = {};
        let geoNeighbors = [];
     
        const projection = d3.geoNaturalEarth1()
            .scale(width / 6.5)
            .translate([width / 2, height / 2]);
        const path = d3.geoPath().projection(projection);
        function initMap() {
            svg = d3.select("#world-map")
                .append("svg")
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("preserveAspectRatio", "xMidYMid meet");
             
            const zoom = d3.zoom()
                .scaleExtent([1, 8])
                .on('zoom', zoomed);
             
            svg.call(zoom);
             
            g = svg.append("g");
             
            g.append("path")
                .datum({type: "Sphere"})
                .attr("class", "ocean")
                .attr("d", path);
             
            pixelLayer = g.append("g").attr("class", "pixel-layer");
            countryLayer = g.append("g").attr("class", "country-layer");
         
            d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json").then(function(world) {
                const originalGeometries = world.objects.countries.geometries;
                geoNeighbors = topojson.neighbors(originalGeometries);
                originalGeometries.forEach((geo, i) => {
                    idToGeoIndex[geo.id] = i;
                });
             
                const countries = topojson.feature(world, world.objects.countries);
                countriesData = countries.features;
             
                // Sort countries alphabetically by name
                countriesData.sort((a, b) => a.properties.name.localeCompare(b.properties.name));
             
                // Populate start country select
                const select = document.getElementById('start-country');
                countriesData.forEach(country => {
                    const option = document.createElement('option');
                    option.value = country.id;
                    option.textContent = country.properties.name;
                    select.appendChild(option);
                });
             
                countriesData.forEach(country => {
                    countryOwners[country.id] = 'neutral';
                    countryPixels[country.id] = createPixelsForCountry(country);
                });
             
                countryLayer.selectAll(".country")
                    .data(countriesData)
                    .enter()
                    .append("path")
                    .attr("class", "country")
                    .attr("d", path)
                    .attr("data-id", d => d.id)
                    .classed("neutral", true)
                    .on("click", handleCountryClick);
                    // Removed mouseover and title for minimalism
            });
        }
        function zoomed(event) {
            g.attr('transform', event.transform);
        }
        function resetZoom() {
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity,
                d3.zoomTransform(svg.node()).invert([width / 2, height / 2])
            );
        }
        function createPixelsForCountry(country) {
            const bounds = path.bounds(country);
            const pixels = [];
         
            for (let x = Math.floor(bounds[0][0]); x < bounds[1][0]; x += pixelSize) {
                for (let y = Math.floor(bounds[0][1]); y < bounds[1][1]; y += pixelSize) {
                    const point = [x + pixelSize/2, y + pixelSize/2];
                    const coords = projection.invert(point);
                 
                    if (coords && d3.geoContains(country, coords)) {
                        pixels.push({
                            x: x,
                            y: y,
                            owner: 'neutral',
                            element: null
                        });
                    }
                }
            }
         
            pixels.forEach(pixel => {
                const rect = pixelLayer.append("rect")
                    .attr("class", "pixel")
                    .attr("x", pixel.x)
                    .attr("y", pixel.y)
                    .attr("width", pixelSize)
                    .attr("height", pixelSize)
                    .attr("fill", "transparent")
                    .attr("stroke", "none");
                pixel.element = rect;
            });
         
            return pixels;
        }
        function handleCountryHover(event, country) {
            // Removed for minimalism
        }
        function handleCountryClick(event, d) {
            if (warInProgress) return;
         
            const country = d;
            countryLayer.selectAll(".country").classed('target', false);
         
            let title = country.properties.name;
            let text = '';
            let showAttack = false;
            let showReset = false;
         
            if (countryOwners[country.id] === 'player') {
                text = '–≠—Ç–æ –≤–∞—à–∞ —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏—è.';
            } else if (countryOwners[country.id] === 'neutral') {
                const hasNeighbor = getPlayerCountries().some(pc => isNeighbor(pc, country));
                if (hasNeighbor) {
                    targetCountry = country;
                    text = '–•–æ—Ç–∏—Ç–µ –∞—Ç–∞–∫–æ–≤–∞—Ç—å —ç—Ç—É —Å—Ç—Ä–∞–Ω—É?';
                    showAttack = true;
                    // Removed adding 'target' class to avoid thick borders
                } else {
                    text = '–≠—Ç–∞ —Å—Ç—Ä–∞–Ω–∞ –Ω–µ –≥—Ä–∞–Ω–∏—á–∏—Ç —Å –≤–∞—à–∏–º–∏ —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏—è–º–∏. –ê—Ç–∞–∫–∞ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞.';
                }
            }
         
            showModal(title, text, showAttack, showReset);
        }
        function attackCountryAction() {
            // Removed, handled in modal
        }
        function cancelSelection() {
            // Removed, handled in modal
        }
        function updateButtons() {
            // Removed
        }
        function startWar(defender) {
            warInProgress = true;
         
            countryLayer.select(`path[data-id="${defender.id}"]`).classed('neutral', false).classed('warring', true);
            const defenderPixels = countryPixels[defender.id];
            defenderPixels.forEach(p => {
                p.element.attr('fill', '#1a2535');
                p.owner = 'neutral';
            });
         
            const playerCountries = getPlayerCountries();
            const borderingPlayers = playerCountries.filter(pc => isNeighbor(pc, defender));
         
            let attackerBorder = [];
            borderingPlayers.forEach(bp => {
                attackerBorder.push(...countryPixels[bp.id]);
            });
         
            let capturedCount = 0;
            const totalPixels = defenderPixels.length;
         
            const warInterval = setInterval(() => {
                const uncapturedPixels = defenderPixels.filter(p => p.owner === 'neutral');
             
                if (uncapturedPixels.length === 0) {
                    clearInterval(warInterval);
                    countryOwners[defender.id] = 'player';
                    countryLayer.select(`path[data-id="${defender.id}"]`).classed('warring', false).classed('player', true);
                    defenderPixels.forEach(p => {
                        p.element.attr('fill', 'transparent');
                    });
                 
                    if (targetCountry) {
                        countryLayer.select(`path[data-id="${targetCountry.id}"]`).classed('target', false);
                    }
                    targetCountry = null;
                    warInProgress = false;
                    checkWinCondition();
                    return;
                }
             
                const pixelsToCapture = Math.min(3 + borderingPlayers.length, uncapturedPixels.length);
             
                for (let i = 0; i < pixelsToCapture; i++) {
                    let targetPixel;
                 
                    const borderPixels = uncapturedPixels.filter(p => {
                        return attackerBorder.some(ap => {
                            const dist = Math.sqrt(Math.pow(ap.x - p.x, 2) + Math.pow(ap.y - p.y, 2));
                            return dist < pixelSize * 3;
                        });
                    });
                 
                    if (borderPixels.length > 0) {
                        targetPixel = borderPixels[Math.floor(Math.random() * borderPixels.length)];
                    } else {
                        targetPixel = uncapturedPixels[Math.floor(Math.random() * uncapturedPixels.length)];
                    }
                 
                    targetPixel.owner = 'player';
                    targetPixel.element
                        .attr('fill', '#ff6b6b');
                    // Removed conquered class for performance
                 
                    attackerBorder.push(targetPixel);
                    capturedCount++;
                }
             
                // Removed progress text
             
            }, gameSpeed);
        }
        function isNeighbor(country1, country2) {
            const index1 = idToGeoIndex[country1.id];
            const index2 = idToGeoIndex[country2.id];
            return geoNeighbors[index1].includes(index2);
        }
        function getPlayerCountries() {
            return countriesData.filter(c => countryOwners[c.id] === 'player');
        }
        function updateInfoText(text) {
            // Removed
        }
        function checkWinCondition() {
            const neutralCount = Object.values(countryOwners).filter(o => o === 'neutral').length;
            if (neutralCount === 0) {
                setTimeout(() => {
                    showModal('üèÜ –ü–û–õ–ù–ê–Ø –ü–û–ë–ï–î–ê!', '–í—ã –∑–∞—Ö–≤–∞—Ç–∏–ª–∏ –≤—Å–µ —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏ –º–∏—Ä–∞!', false, true);
                 
                    // Confetti celebration
                    const confettiSettings = { target: 'world-map', max: 200, size: 2, animate: true };
                    const confetti = new ConfettiGenerator(confettiSettings);
                    confetti.render();
                 
                    setTimeout(() => confetti.clear(), 5000);
                }, 500);
            }
        }
        function toggleSpeed() {
            // Removed
        }
        function resetGame() {
            if (warInProgress) return;
         
            Object.keys(countryOwners).forEach(id => {
                countryOwners[id] = 'neutral';
                const pixels = countryPixels[id];
                pixels.forEach(pixel => {
                    pixel.owner = 'neutral';
                    pixel.element.attr('fill', 'transparent');
                });
                countryLayer.select(`path[data-id="${id}"]`)
                    .classed('player', false)
                    .classed('warring', false)
                    .classed('neutral', true)
                    .classed('target', false);
            });
         
            targetCountry = null;
            hoveredCountry = null;
         
            // Show start menu again
            document.getElementById('start-menu').style.display = 'flex';
            document.getElementById('world-map').classList.add('hidden');
            document.getElementById('world-map').style.position = '';
            document.getElementById('world-map').style.inset = '';
        }
        function showModal(title, text, showAttack = false, showReset = false) {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-text').textContent = text;
            document.getElementById('modal-attack').style.display = showAttack ? 'inline-flex' : 'none';
            document.getElementById('modal-reset').style.display = showReset ? 'inline-flex' : 'none';
            document.getElementById('modal').style.display = 'flex';
        }
        function hideModal() {
            document.getElementById('modal').style.display = 'none';
        }
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            feather.replace();
         
            // Load confetti script if needed
            if (!window.ConfettiGenerator) {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js';
                document.head.appendChild(script);
            }
         
            const modalAttack = document.getElementById('modal-attack');
            const modalClose = document.getElementById('modal-close');
            const modalReset = document.getElementById('modal-reset');
         
            modalAttack.addEventListener('click', () => {
                if (targetCountry) {
                    startWar(targetCountry);
                    targetCountry = null;
                }
                hideModal();
            });
         
            modalClose.addEventListener('click', hideModal);
         
            modalReset.addEventListener('click', () => {
                resetGame();
                hideModal();
            });
         
            // Start button handler
            document.getElementById('start-btn').addEventListener('click', function() {
                const startId = document.getElementById('start-country').value;
                if (!startId) return;
             
                const startCountry = countriesData.find(c => c.id === startId);
                countryOwners[startId] = 'player';
                countryLayer.select(`path[data-id="${startId}"]`).classed('neutral', false).classed('player', true);
             
                document.getElementById('start-menu').style.display = 'none';
                document.getElementById('world-map').classList.remove('hidden');
                document.getElementById('world-map').style.position = 'fixed';
                document.getElementById('world-map').style.inset = '0';
             
                showModal('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!', `–í—ã –Ω–∞—á–∞–ª–∏ —Å ${startCountry.properties.name}. –ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ —Å—Ç—Ä–∞–Ω—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏–ª–∏ –∞—Ç–∞–∫–∏.`, false, false);
            });
        });
    </script>
</body>
</html>
